## 퀵정렬 강의 정리
<br><br>
* * *
<br>
- 퀵정렬 : 어떤 한 데이터 (랜덤 or 중앙값 or 첫번째값 - 정렬이 안되었다는 가정하에)를 pivot(기준)으로 삼아 있어야할 위치를 찾아 옮기고 고정한 뒤 양 옆의 데이터들 중에서도 pivot을 두어 같은 
방식으로 진행하며 정렬을 완료하는 알고리즘<br><br>
- 재귀를 이용해야하기 떄문에 재귀함수에 대한 이해가 필요함. (어찌보면 병합정렬의 방법과 유사)
<br><br><br>

### 퀵정렬의 원리
(구현을 한 것을 기준으로 하자면 나는 구현을 첫번째값을 pivot으로 두고 하였다.)
- 정렬을 수행할 함수의 인자로 배열 arr, 첫번째 인덱스값(first - 0), 마지막 인덱스값(last - arr.length)를 전달한다.
- 첫번쨰를 pivot으로 하고 반복문을 통해 pivot값보다 작은 값을 만나면 pivot을 하나 증가시키면서 해당 위치에 있는 데이터를 i번째 인덱스값과 교환한다.
- 배열을 모두 돌고나면 pivot이 첫번째 데이터가 있어야할 위치라고 판단하여 교환해 위치하고 왼쪽에는 정렬되지않은 pivot보다 작은 데이터들, 오른쪽에는 정렬되지 않은 pivot보다 큰 데이터들이 위치하게 된다.
- 왼쪽 데이터들은 다시 (arr, 0, pivot-1)를 인자로 재귀함수를 돌리고 오른쪽 데이터들은 (arr, pivot+1, length-1)로 돌린다.
- 반환은 first가 last보다 커지는 순간 arr를 반환하여 재귀함수를 끝낸다.
- 정렬 완료!

<br><br>

### 퀵정렬의 빅오
  - 정렬해야할 데이터의 수가 2제곱씩 늘어날 수록 pivot으로 나눠야하는 수가 1씩 늘어나고(log n)<br> 분해한 단계마다 비교연산을 진행하기 때문에(n) 평균적인 **빅오는 O(n log n)** 이다.
<br>

- (pivot을 첫번쨰 값으로 정할 경우) 만약 데이터가 대부분 or 모두 정렬되어있다면 **최악의 경우로 O(n^2)** 가 나오게 된다. 첫번째가 나누는 기준인데 정렬이 되어있으면 분해를 n번 하게되기 때문에
n번의 분해, n번의 비교를 하게 되기 때문이다. 그렇기 때문에 랜덤값으로 pivot을 정하거나 중앙값으로 pivot을 정하는 경우가 많지만 그래도 n번 분할을 하게될 경우의 수가 아에 없지 않기 때문에 최악의 경우 O(n)이 나오게된다.

- 대부분이 정렬되어있을 경우 사용하기 꺼려지는 정렬알고리즘인 듯 하다 - 대부분 정렬되어있다면 삽입정렬을 사용해보자.
